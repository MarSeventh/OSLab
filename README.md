# Lab2实验报告

## 一、思考题

### 1、请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址 是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地 址？

```
两者使用的都是虚拟地址。
```

### 2、请思考下述两个问题：

###  • 从可重用性的角度，阐述用宏来实现链表的好处。

###  • 查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实 现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差 异。

```
从可重用性的角度来看，用宏来实现链表可以不局限于链表的具体类型和用途，在不同的使用场景均可用同样的宏来实现同样的功能，具有很好的可重用性。
在插入操作时，如果在给定链表项后方插入，三者效率相同。如果要在给定链表项前方插入，单向链表需要再次遍历，而双向链表和循环链表则不用，除此之外，如果要在链表尾部插入节点，循环链表则不需要遍历，效率更高。
在删除操作时，如果是删除给定链表项，单向链表依然要再次遍历寻找前驱结点，另外两者则不用，如果要删除尾部节点，循环链表也无需遍历，效率更高。
```

### 3、请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳 理清楚，选择正确的展开结构。

```C
正确结构：C
1 C:
2 struct Page_list{
3       struct {
4            struct {
5                 struct Page *le_next;
6                 struct Page **le_prev;
7            } pp_link;
8            u_short pp_ref;
9       }* lh_first;
10 }    
```

### 4、请思考下面两个问题： 

### • 请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。

###  • 请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。

```
1、
ASID的作用是将虚拟地址映射到物理地址，并区分不同的虚拟地址，使得每个进程在使用虚拟地址时都可以认为自己拥有整个物理地址空间，并且不会相互干扰。ASID实际上在保证多任务和共享内存的同时，实现了虚拟内存的隔离和高效。
2、
ASID占据6位，因此允许容纳不同地址空间的最大数量是64个。
```

### 5、请回答下述三个问题： 

### • tlb_invalidate 和 tlb_out 的调用关系？

###  • 请用一句话概括 tlb_invalidate 的作用。

###  • 逐行解释 tlb_out 中的汇编代码。

```asm
1、
tlb_invalidate调用tlb_out
2、
tlb_invalidate 可以实现删除特定虚拟地址在 TLB 中的旧表项
3、
  3 LEAF(tlb_out) //函数开始
  4 .set noreorder  //以下指令不可重排序
  5         mfc0    t0, CP0_ENTRYHI  //将ENTRYHI寄存器中的值取到t0里
  6         mtc0    a0, CP0_ENTRYHI  //将a0存到ENTRYHI里
  7         nop //空指令
  8         /* Step 1: Use 'tlbp' to probe TLB entry */
  9         /* Exercise 2.8: Your code here. (1/2) */
 10         tlbp //根据 EntryHi 中的 Key 查找对应的旧表项，将表项的索引存入 Index
 11         nop
 12         /* Step 2: Fetch the probe result from CP0.Index */
 13         mfc0    t1, CP0_INDEX //将Index的值存入t1寄存器
 14 .set reorder //以下指令可重排序
 15         bltz    t1, NO_SUCH_ENTRY //若t1小于0，跳转到NO_SUCH_ENTRY
 16 .set noreorder //以下指令不可重排序
 17         mtc0    zero, CP0_ENTRYHI  //将0写入ENTRYHI寄存器
 18         mtc0    zero, CP0_ENTRYLO0  //将0写入ENTRYLOW寄存器
 19         nop
 20         /* Step 3: Use 'tlbwi' to write CP0.EntryHi/Lo into TLB at CP0.Index  */
 21         /* Exercise 2.8: Your code here. (2/2) */
 22         tlbwi  //将 EntryHi 和 EntryLo 中的值写入索引指定的表项。此时旧表项的 Key 和 Data 被清零，实现                    //将其无效化
 23 .set reorder //以下指令可重排序
 24 
 25 NO_SUCH_ENTRY:  //NO_SUCH_ENTRY的入口
 26         mtc0    t0, CP0_ENTRYHI  //将t0写入ENTRYHI寄存器
 27         j       ra  //跳出函数
 28 END(tlb_out) //tlb_out函数结束
```

### 6、任选下述二者之一回答：

###  • 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上 的区别。

###  • 简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上 的区别。

```
1、X86体系结构中的内存管理机制：
物理地址空间：x86架构支持的物理地址空间范围是4GB，这个范围内的每个字节都可以被访问。物理地址是由CPU直接生成的，用于访问物理内存。

虚拟地址空间：x86架构支持的虚拟地址空间范围也是4GB。虚拟地址是应用程序看到的地址，应用程序使用虚拟地址来访问内存。虚拟地址需要经过地址转换机制转换成物理地址才能访问内存。

分段机制：x86架构的内存管理采用了分段机制，把物理地址空间划分成多个段，每个段的大小可以不同。段的大小和起始地址都存储在段描述符中，段描述符存储在全局描述符表（GDT）中。通过GDT可以实现对段的管理和访问控制。

分页机制：x86架构的内存管理还采用了分页机制，将虚拟地址空间划分成大小相等的页面，通常为4KB。每个页面都对应着物理内存中的一个页面帧。通过页表实现虚拟地址到物理地址的转换，页表存储在内存中，通过CR3寄存器指向。在进行地址转换时，CPU会先使用段寄存器中的段基址和段内偏移量计算出线性地址，然后再使用页表将线性地址转换成物理地址。

内存保护机制：x86架构还提供了内存保护机制，可以通过GDT和页表实现对内存访问的保护和限制。可以为每个段和每个页面设置访问权限，只有具有足够权限的程序才能访问内存。同时还可以使用特殊的段和页面来实现对内存的共享和保护。
2、X86架构和MIPS在内存管理上的区别：
X86架构：X86架构的内存管理采用了分段和分页的方式，每个进程都有一个独立的线性地址空间，通过段寄存器和页表来映射到物理地址空间。X86架构支持多种内存保护模式，如实模式、保护模式、虚拟8086模式和长模式。

MIPS架构：MIPS架构的内存管理只采用了分页的方式，每个进程都有一个统一的虚拟地址空间，通过TLB（转换后备缓冲器）来映射到物理地址空间。MIPS架构支持两种内存保护模式，即内核模式和用户模式。
```

### 7、在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存 储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。 因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。 现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地 址为 PTbase，请计算：

###  • 三级页表页目录的基地址。

###  • 映射到页目录自身的页目录项（自映射）。

```
1、
页目录基地址=PTbase | (PTbase >> 9)
2、
自映射项 = PTbase | (PTbase >> 9) | (PTbase >> 18)
```

## 二、难点分析

本次实验中，我们的核心任务是**掌握物理内存和虚拟内存的管理，以及掌握TLB清除与重填的流程**。

**第一个难点**就在于掌握R3000上虚拟地址到物理地址的映射与寻址规则：

> kseg0：虚拟地址最高位置0得到物理地址，通过cache访存。
>
> kseg1：虚拟地址高三位置0得到物理地址，不通过cache访存。
>
> kuseg：通过TLB获取物理地址，通过cache访存。
>
> 具体如下图：
>
> ![image-20230327171038476](https://alist.sanyue.site/d/imgbed/202311252220647.png)

**第二个难点**在于掌握空闲链表的使用以及Page结构体和物理页面的转化：

> 空闲链表可以使用一系列链表宏进行方便的操作。
>
> Page_list的结构如下：
>
> ```C
> 2 struct Page_list{
> 3       struct {
> 4            struct {
> 5                 struct Page *le_next;
> 6                 struct Page **le_prev;
> 7            } pp_link;
> 8            u_short pp_ref;
> 9       }* lh_first;
> 10 }    
> ```
>
> Page结构体定义如下：
>
> ```C
> 3 struct Page {
> 4 Page_LIST_entry_t pp_link; /* free list link */
> 5
> 6 // Ref is the count of pointers (usually in page table entries)
> 7 // to this page. This only holds for pages allocated using
> 8 // page_alloc. Pages allocated at boot time using pmap.c's "alloc"
> 9 // do not have valid reference count fields.
> 10
> 11 u_short pp_ref;
> 12 };
> ```
>
> Page到物理页面的转换可以使用`page2pa`函数，物理页面到Page的转换可以使用`pa2page`函数。

**第三个难点**就在于两级页表的地址转换流程：

> 具体流程如下图：
>
> ![image-20230327173035730](https://alist.sanyue.site/d/imgbed/202311252221068.png)
>
> 要注意每一级页表存的都是下一级的物理页号。
>
> 访问页目录以及填充页表项的函数具体流程如下图：
>
> ![image-20230327175601520](https://alist.sanyue.site/d/imgbed/202311252221856.png)
>
> 注意掌握`page_insert`、`page_lookup`和`page_remove`函数的功能和实现方式。

**最后一个难点**便在于TLB表项的维护：

> 1. 更新页表中虚拟地址对应的页表项的同时，将 TLB 中对应的旧表项无效化 
>
>    TLB旧表项的无效化可通过`tlb_invalidate`实现。
>
> 2. 在下一次访问该虚拟地址时触发 TLB 重填异常，对 TLB 进行重填
>
>    TLB重填过程由`do_tlb_refill`完成，具体流程如下：
>
>    > 1. 从 BadVAddr 中取出引发 TLB 缺失的虚拟地址。
>    >
>    > 2. 从 EntryHi 的 6 – 11 位取出当前进程的 ASID。在 Lab3 的代码中，会在进程切换时修改 EntryHi 中的 ASID，以标识访存所在的地址空间。 
>    > 3. 以虚拟地址和 ASID 为参数，调用 _do_tlb_refill 函数。该函数是 TLB 重填过程的核心，其功能是根据虚拟地址和 ASID 查找页表，返回包含物理地址的页表项。为了保存汇编函数现场中的返回地址，在调用函数前，我们将 ra 寄存器的值保存在一个“全局变量” 中。 
>    > 4. 将物理地址存入 EntryLo , 并执行 tlbwr 将此时的 EntryHi 与 EntryLo 写入到 TLB 中 （在发生 TLB 缺失时，EntryHi 中保留了虚拟地址相关信息）。

## 三、心得体会

本次实验我们初探了物理内存和虚拟内存管理的相关内容，实验的总体难度适中，有部分地方难度较大，在上文中已经有所提及。

通过这次实验，我感触最深的地方便是从两级页表向物理地址映射的过程，这个过程虽然不是很容易理解，但是理解之后便能看出其中的精巧之处。在这一过程中，尤其要注意的一点就是无论是哪一级页表，其中前二十位存的都是物理页框号，与虚拟页框号无关。在这一部分中，还要注意理解理论课中所学习的页目录自映射的方法，虽然我们的实验中未曾用到这种映射方式，但是这种方式能够让我们对于虚拟地址和物理地址的转换了解地更加深刻。

页目录自映射的具体过程如下图：

> ![image-20230327212436215](https://alist.sanyue.site/d/imgbed/202311252221366.png)
>
> 其中巧妙之处便在于，页目录中总有一个页目录项会映射到该页目录自身的物理地址，并且页目录自身虚拟地址和自映射项的虚拟地址都可以通过计算得出。因此可以更加方便地寻找到页目录的物理地址。

其次，令我感触比较深刻的还有在处理空闲链表时对宏的充分使用，利用提前定义好的宏轻松地实现寻找链表头，链表初始化，在特定位置插入删除元素等操作，极大地简化了代码量并且提高了代码可读性。在今后自己设计软件时，对于这种重复操作具有高度可抽象化的情况，我们也可以参考这种思路来优化自己的代码。

总而言之，Lab2相对于前两次实验在难度上有了一定的提升，理解难度也相对加大，但是我也通过本次实验学到了不少有用的设计思想，并且对操作系统内存管理之精巧有了更加深刻的认识，收获颇丰。

